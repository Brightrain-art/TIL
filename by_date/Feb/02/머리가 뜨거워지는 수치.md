# SWEA - 4834
## 숫자 카드 문제

- 쉬운 문제를 어렵게 풀었씁니다. 굉장히 마음이 아픕니다. 그래서 자려고 누웠다가 다시 일어나서 정리합니다.

```python
import collections # collections 모듈 import

TC = int(input()) # 테스트 케이스

for test_case in range(1, TC + 1): # 테스트 케이스 수 만큼 반복

    N = int(input()) # 카드 개수

    card_list = [cards for cards in input()] # 카드 리스트화

    cnt_dict = collections.Counter(card_list) # collections 모듈의 Counter 메서드 활용 빈도수 dict 생성
    cnt_list = [kv for kv in cnt_dict.items()] # key, value 값 items 로 추출
    cnt_list.sort(key= lambda x: (x[1], x[0]), reverse= True) # 빈도수, 빈도수 같으면 카드 크기 순 정렬

    print(f'#{test_case} {cnt_list[0][0]} {cnt_list[0][1]}') # 튜플의 0번 인덱스가 카드 숫자, 1번 인덱스가 빈도수 출력
```
> 의미 없이 collections 모듈 불러와서 해결. 물론 해결은 했지만 결코 원하는 방향은 아니었음.

- 정규 수업에서 풀이하는 문제들은 최대한 모듈이나 내부함수의 도움 없이 풀고 싶었는데 그러지 못했습니다.

- 정규수업의 문제가 아니었다면 이전에 배우고 써먹어야겠다고 생각했던 collections 모듈의 Count 메서드, most_common 메서드를 사용해서 풀어낸 건 만족했을 듯 합니다.


# 강사님의 Solutuins
## Solution no.1 Sliding Window
```python
import sys

sys.stdin = open("input.txt")


T = int(input())

for tc in range(1, T + 1):
    N, M = map(int, input().split())
    numbers = list(map(int, input().split()))

    # 1. 첫 번째 구간의 합 계산 및 초기화
    # 슬라이딩 윈도우의 시작점
    current_sum = sum(numbers[:M])
    max_sum = current_sum
    min_sum = current_sum

    # 2. 윈도우를 한 칸씩 이동하며 합계 갱신
    # 첫 구간(인덱스 0부터)은 이미 계산했으므로, 두 번째 구간부터 탐색
    # range(1, N - M + 1): 윈도우의 시작 인덱스
    for i in range(1, N - M + 1):
        # 이전 구간합에서 맨 앞 요소를 빼고, 현재 구간의 마지막 요소를 더함
        previous_first = numbers[i - 1]
        current_last = numbers[i + M - 1]
        current_sum = current_sum - previous_first + current_last

        # 3. 최대값과 최소값 갱신
        if current_sum > max_sum:
            max_sum = current_sum
        if current_sum < min_sum:
            min_sum = current_sum

    # 4. 최종 결과 출력
    result = max_sum - min_sum
    print(f"#{tc} {result}")
```

## Solution no.2 Brute Force
```python
import sys

sys.stdin = open("input.txt")


T = int(input())

for tc in range(1, T + 1):
    N, M = map(int, input().split())
    numbers = list(map(int, input().split()))

    # 1. 초기값 설정
    # 비교를 위해 첫 번째 구간의 합을 최대값(max_sum)과 최소값(min_sum)의 초기값으로 설정
    # 파이썬에서는 음수, 양수 극단값 대신 첫 결과값을 초기값으로 쓰는 것이 안전
    first_sum = 0
    for i in range(M):
        first_sum += numbers[i]
    max_sum = first_sum
    min_sum = first_sum

    # 2. 모든 구간을 순회하며 구간합 계산
    # 구간의 시작점이 될 수 있는 모든 위치(i)를 순회
    # 예: N=10, M=3일 때, 시작점은 0~7. 즉, range(10-3+1)
    for i in range(N - M + 1):
        # 현재 구간(i에서 시작하는 M개의 요소)의 합 계산
        current_sum = 0
        for j in range(i, i + M):
            current_sum += numbers[j]

        # 3. 최대값과 최소값 갱신
        if current_sum > max_sum:
            max_sum = current_sum
        if current_sum < min_sum:
            min_sum = current_sum

    # 4. 최종 결과(최대 구간합과 최소 구간합의 차이) 출력
    result = max_sum - min_sum
    print(f"#{tc} {result}")

```