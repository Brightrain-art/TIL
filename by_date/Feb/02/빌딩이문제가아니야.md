# SWEA - 1206
## 빌딩 조망권 구하는 문제


```python
test_case = 0

for test_case in range(1, 11): # 범위 지정

    N = int(input()) # 빌딩 수

    building_height = list(map(int, input().split()))

    fine_floor = 0 # 조망권 층 수

    for order in range(2, N-2): # 진짜 모름 왜 N -3 이 아닌거에요
        b2 = building_height[order-2] # 인덱스 -2
        b1 = building_height[order-1] # 인덱스 -1
        check = building_height[order] # 인덱스 0
        a1 = building_height[order+1] # 인덱스 +1
        a2 = building_height[order+2] # 인덱스 +2
        if check > b2 and check > b1 and check > a1 and check > a2: # 다른 모든 층 보다 가장 높으면
            fine_floor += check - max(b2, b1, a1, a2) # 그 중 가장 높은 값 뺌

    print(f'#{test_case} {fine_floor}') # 출력
```

- 무난하게 풀이했습니다. 조건문 부분을 동치를 이용해 짧게 하고 싶었지만 실패했습니다.


# 강사님의 Solution
## Solution no. 1
```python
import sys


def good_view(arr, N):
    result = 0

    # 양 끝 두자리 땅은 건물이 없음.
    for i in range(2, N - 2):

        cur_height = arr[i]  # 현재 후보 건물 높이 (i번째)

				# 현재 건물의 양 옆 두 칸의 건물 중 가장 높은 건물 높이
        max_neighbor_height = max(arr[i - 2:i] + arr[i + 1:i + 3])  

        # 현재 건물의 높이가 양 옆 두 칸의 건물 높이보다 높다면
        if max_neighbor_height < cur_height:
            result += cur_height - max_neighbor_height  # 그 차이만큼 조망권이 확보된다.

    return result


sys.stdin = open('input.txt')

T = 10

for tc in range(1, T + 1):
    N = int(input())
    arr = list(map(int, input().split()))

    print(f'#{tc} {good_view(arr, N)}')
```
- 제 풀이와 결이 비슷한 풀이라고 느꼈습니다만 더 고차원 적인 풀이라고 생각합니다. 우선 변수의 개수가 적어 실수의 위험이 적습니다. 그 수가 몇 개 되지 않았기에 망정이지 참.. 슬라이싱을 이용해 풀이한다면 실수도 더 적어질게 확실합니다.

- 또한 맥스값을 바로 현재 빌딩 높이와 바로 비교한 부분도 그렇습니다. 생각해보면 맥스값이 현재 높이보다 작으면 비교할 필요도 없는 건데 이 부분은 제가 로직을 더 다듬지 않은 데에서 나온 큰 차이입니다.

- 함수로 정의한 부분도 그렇습니다. 지금은 인풋값도 작고 함수 내용도 크게 복잡하지 않아서 큰 차이는 없지만 문제 수준이 높아질 수록 이 차이는 확연해 질 것입니다. 함수를 사용하는 연습을 해야겠습니다.

## Solution no.2
```python
import sys

sys.stdin = open('input.txt')

for tc in range(1, 11):
    N = int(input())
    arr = list(map(int, input().split()))

    result = 0
    # 양 끝 2자리 무시
    for i in range(2, N-2):
        # 현재 조사대상의 높이 : 최대 조망권
        tmp = arr[i]
        # 현재 위치를 기준으로 좌우 2칸씩 조사
        for j in range(i-2, i+3):
            # 나랑 나를 비교할 필요 없음
            if i == j:
                continue
            # 조사 대상이 양 옆보다 크고,
            # 그 둘의 차이가 최대 조망권보다 작으면
            if arr[i] > arr[j] and tmp > arr[i] - arr[j]:
                # 최대 조망권을 변경
                tmp = arr[i] - arr[j]
            # 만약 조사 대상의 양옆이 나와 크거나 같은 경우가 한번이라도 있으면
            # 더 이상 조사할 필요 없음
            elif arr[i] <= arr[j]:
                break
        # break문으로 종료되지 않았다면 (더 이상 조사할 필요가 없는 경우가 없었다면)
        # 정상적으로 모두 조사한 것이므로
        else:
            # i번쨰 위치 건물의 조망권 크기 더하기
            result += tmp
    print(f'#{tc} {result}')
```
- 리스트를 훑고 갱신하며 최대값을 구하는 방법을 사용한게 인상적입니다. 최대값을 구할 때 항상 max 함수를 이용하여 풀었다면 생각하지 못할 풀이입니다. 저는 이런 문제를 풀 때 보통 tmp 값의 리스트를 만들어 할당하고 max 함수를 이용해 최대값을 구하는데 더 효율적인 방법이라는 생각이 들었습니다. 성능 측면에서도 차이가 있을지 궁금합니다.
